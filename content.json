{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/10/09/hello-world/"},{"title":"敲起来！Koa2 + Vue3 演练大文件分片上传","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251&lt;template&gt; &lt;div class=&quot;file-upload-fragment&quot;&gt; &lt;div class=&quot;file-upload-fragment-container&quot;&gt; &lt;el-upload class=&quot;fufc-upload&quot; action=&quot;&quot; :on-change=&quot;handleFileChange&quot; :auto-upload=&quot;false&quot; :show-file-list=&quot;false&quot; &gt; &lt;template #trigger&gt; &lt;el-button class=&quot;fufc-upload-file&quot; size=&quot;small&quot; type=&quot;primary&quot;&gt; 选择文件 &lt;/el-button&gt; &lt;/template&gt; &lt;el-button class=&quot;fufc-upload-server&quot; size=&quot;small&quot; type=&quot;success&quot; @click=&quot;handleUploadFile&quot; &gt; 上传到服务器 &lt;/el-button&gt; &lt;el-button class=&quot;fufc-upload-stop&quot; size=&quot;small&quot; type=&quot;primary&quot; @click=&quot;stopUpload&quot; &gt; 暂停上传 &lt;/el-button&gt; &lt;el-button class=&quot;fufc-upload-continue&quot; size=&quot;small&quot; type=&quot;success&quot; @click=&quot;continueUpload&quot; &gt;继续上传&lt;/el-button &gt; &lt;/el-upload&gt; &lt;el-progress :percentage=&quot;percentage&quot; color=&quot;#409eff&quot; /&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import { ref, computed } from 'vue'import { postUploadFile, mergeUploadFile, verifyUpload } from '@/api/api.js'import { ElMessage } from 'element-plus'import axios from 'axios'import SparkMD5 from 'spark-md5'const cancelToken = axios.CancelTokenconst chunkSize = 5 * 1024 * 1024/** * @description: 生成文件hash * @param {*} * @return {*} */const createMD5 = (fileChunkList) =&gt; { return new Promise((resolve, reject) =&gt; { const slice = File.prototype.slice || File.prototype.mozSlice || File.prototype.webkitSlice const chunks = fileChunkList.length let currentChunk = 0 let spark = new SparkMD5.ArrayBuffer() let fileReader = new FileReader() fileReader.onload = function (e) { spark.append(e.target.result) currentChunk++ if (currentChunk &lt; chunks) { loadChunk() } else { resolve(spark.end()) } } fileReader.onerror = function (e) { reject(e) } function loadChunk() { fileReader.readAsArrayBuffer(fileChunkList[currentChunk]) } loadChunk() })}let currentFile = ref(null)let chunkFormData = ref([])let fileHash = ref(null)let percentage = computed(() =&gt; { if (!chunkFormData.value.length) return 0 let uploaded = chunkFormData.value.filter((item) =&gt; item.percentage).length return Number(((uploaded / chunkFormData.value.length) * 100).toFixed(2))})/** * @description: 创建文件分片 * @param {*} * @return {*} */const createChunkList = (file, chunkSize) =&gt; { const fileChunkList = [] let cur = 0 while (cur &lt; file.size) { fileChunkList.push(file.slice(cur, cur + chunkSize)) cur += chunkSize } return fileChunkList}/** * @description: 选择文件事件 * @param {*} * @return {*} */const handleFileChange = async (file) =&gt; { if (!file) return currentFile.value = file}/** * @description: 分片上传回调 * @param {*} * @return {*} */const uploadProgress = (item) =&gt; { return (e) =&gt; { item.percentage = parseInt(String((e.loaded / e.total) * 100)) }}/** * @description: 暂停上传 * @param {*} * @return {*} */const stopUpload = () =&gt; { chunkFormData.value.forEach((data) =&gt; { data.cancelToken.cancel('取消上传') data.cancelToken = cancelToken.source() })}/** * @description: 断点续传 * @param {*} * @return {*} */const continueUpload = () =&gt; { let notUploaded = chunkFormData.value.filter((item) =&gt; !item.percentage) Promise.all( notUploaded.map((data) =&gt; { return new Promise((resolve, reject) =&gt; { postUploadFile( data.formData, uploadProgress(data), data.cancelToken.token ) .then((data) =&gt; { resolve(data) }) .catch((err) =&gt; { reject(err) }) }) }) ).then((data) =&gt; { if (!data.includes(undefined)) { mergeUploadFile({ fileName: currentFile.value.name, fileHash: fileHash.value, chunkSize: chunkSize }) } })}/** * @description: 文件上传 * @param {*} * @return {*} */const handleUploadFile = async () =&gt; { if (!currentFile) { ElMessage.warning('请选择文件') return } // 文件分片 let fileChunkList = createChunkList(currentFile.value.raw, chunkSize) // 文件hash // let fileHash = await MultiThreadCreateMD5(currentFile.value.raw, chunkSize) fileHash.value = await createMD5(fileChunkList, chunkSize) // 判断文件是否存在 let { isUploaded } = await verifyUpload({ fileHash: fileHash.value, fileName: currentFile.value.name }) if (isUploaded) { ElMessage.warning('文件已存在') return } let chunkList = fileChunkList.map((file, index) =&gt; { return { file: file, chunkHash: fileHash.value + '-' + index, fileHash: fileHash.value } }) chunkFormData.value = chunkList.map((chunk) =&gt; { let formData = new FormData() formData.append('chunk', chunk.file) formData.append('chunkHash', chunk.chunkHash) formData.append('fileHash', chunk.fileHash) return { formData: formData, percentage: 0, cancelToken: cancelToken.source() } }) continueUpload()}&lt;/script&gt;&lt;style scoped lang=&quot;scss&quot;&gt;.file-upload-fragment { width: 100%; height: 100%; padding: 10px; &amp;-container { position: relative; margin: 0 auto; width: 600px; height: 300px; top: calc(50% - 150px); min-width: 400px; .fufc-upload { display: flex; justify-content: space-between; align-items: center; } .el-progress { margin-top: 10px; ::v-deep(.el-progress__text) { min-width: 0px; } } }}&lt;/style&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596const fsExtra = require('fs-extra')const path = require('path')const UPLOAD_DIR = path.resolve(__dirname, '..', 'files')class FileController { static async uploadFile(ctx) { const file = ctx.request.files.chunk const body = ctx.request.body const fileHash = body.fileHash const chunkHash = body.chunkHash const chunkDir = `${UPLOAD_DIR}/${fileHash}` const chunkIndex = chunkHash.split('-')[1] const chunkPath = `${UPLOAD_DIR}/${fileHash}/${chunkIndex}` // 不存在目录，则新建目录 if (!fsExtra.existsSync(chunkDir)) { await fsExtra.mkdirs(chunkDir) } // 判断切片是否存在，不存在的移动切片 if (!fsExtra.existsSync(chunkPath)) { await fsExtra.move( file.path, path.resolve(chunkDir, chunkHash.split('-')[1]) ) } ctx.success('received file chunk') } static async mergeUploadFile(ctx) { const params = ctx.request.query const fileHash = params.fileHash const chunkSize = params.chunkSize const fileName = params.fileName const chunkDir = path.resolve(UPLOAD_DIR, fileHash) const chunkPaths = await fsExtra.readdir(chunkDir) const chunkNumber = chunkPaths.length let count = 0 // 切片排序 防止乱序 chunkPaths.sort((a, b) =&gt; a - b) chunkPaths.forEach((chunk, index) =&gt; { const chunkPath = path.resolve(UPLOAD_DIR, fileHash, chunk) // 创建可写流 const writeStream = fsExtra.createWriteStream(fileHash + fileName, { start: index * chunkSize, end: (index + 1) * chunkSize }) const readStream = fsExtra.createReadStream(chunkPath) readStream.on('end', () =&gt; { // 删除切片文件 fsExtra.unlinkSync(chunkPath) count++ // 删除文件夹 if (count === chunkNumber) { fsExtra.rmdirSync(chunkDir) let uploadedFilePath = path.resolve( __dirname, '..', fileHash + fileName ) fsExtra.move(uploadedFilePath, UPLOAD_DIR + '/' + fileHash + fileName) } }) readStream.pipe(writeStream) }) ctx.success('file merged') } static async verifyUpload(ctx) { const params = ctx.request.params const fileHash = params.fileHash const fileName = params.fileName const filePath = path.resolve( __dirname, '..', `files/${fileHash + fileName}` ) if (fsExtra.existsSync(filePath)) { ctx.success( { isUploaded: true }, 'file is uploaded' ) } else { ctx.success( { isUploaded: false }, 'file need upload ' ) } }}module.exports = FileController","link":"/2021/10/09/Koa2-%E5%A4%A7%E6%96%87%E4%BB%B6%E5%88%86%E7%89%87%E4%B8%8A%E4%BC%A0/"}],"tags":[],"categories":[]}